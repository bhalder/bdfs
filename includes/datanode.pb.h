// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datanode.proto

#ifndef PROTOBUF_datanode_2eproto__INCLUDED
#define PROTOBUF_datanode_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_datanode_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultskeepalive_reqImpl();
void InitDefaultskeepalive_req();
void InitDefaultskeepalive_respImpl();
void InitDefaultskeepalive_resp();
void InitDefaultsconnect_reqImpl();
void InitDefaultsconnect_req();
void InitDefaultsconnect_respImpl();
void InitDefaultsconnect_resp();
void InitDefaultsdisconnect_reqImpl();
void InitDefaultsdisconnect_req();
void InitDefaultsdisconnect_respImpl();
void InitDefaultsdisconnect_resp();
inline void InitDefaults() {
  InitDefaultskeepalive_req();
  InitDefaultskeepalive_resp();
  InitDefaultsconnect_req();
  InitDefaultsconnect_resp();
  InitDefaultsdisconnect_req();
  InitDefaultsdisconnect_resp();
}
}  // namespace protobuf_datanode_2eproto
namespace bdfs {
class connect_req;
class connect_reqDefaultTypeInternal;
extern connect_reqDefaultTypeInternal _connect_req_default_instance_;
class connect_resp;
class connect_respDefaultTypeInternal;
extern connect_respDefaultTypeInternal _connect_resp_default_instance_;
class disconnect_req;
class disconnect_reqDefaultTypeInternal;
extern disconnect_reqDefaultTypeInternal _disconnect_req_default_instance_;
class disconnect_resp;
class disconnect_respDefaultTypeInternal;
extern disconnect_respDefaultTypeInternal _disconnect_resp_default_instance_;
class keepalive_req;
class keepalive_reqDefaultTypeInternal;
extern keepalive_reqDefaultTypeInternal _keepalive_req_default_instance_;
class keepalive_resp;
class keepalive_respDefaultTypeInternal;
extern keepalive_respDefaultTypeInternal _keepalive_resp_default_instance_;
}  // namespace bdfs
namespace bdfs {

// ===================================================================

class keepalive_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bdfs.keepalive_req) */ {
 public:
  keepalive_req();
  virtual ~keepalive_req();

  keepalive_req(const keepalive_req& from);

  inline keepalive_req& operator=(const keepalive_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  keepalive_req(keepalive_req&& from) noexcept
    : keepalive_req() {
    *this = ::std::move(from);
  }

  inline keepalive_req& operator=(keepalive_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const keepalive_req& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const keepalive_req* internal_default_instance() {
    return reinterpret_cast<const keepalive_req*>(
               &_keepalive_req_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(keepalive_req* other);
  friend void swap(keepalive_req& a, keepalive_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline keepalive_req* New() const PROTOBUF_FINAL { return New(NULL); }

  keepalive_req* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const keepalive_req& from);
  void MergeFrom(const keepalive_req& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(keepalive_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodename = 1;
  void clear_nodename();
  static const int kNodenameFieldNumber = 1;
  const ::std::string& nodename() const;
  void set_nodename(const ::std::string& value);
  #if LANG_CXX11
  void set_nodename(::std::string&& value);
  #endif
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  ::std::string* mutable_nodename();
  ::std::string* release_nodename();
  void set_allocated_nodename(::std::string* nodename);

  // @@protoc_insertion_point(class_scope:bdfs.keepalive_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  mutable int _cached_size_;
  friend struct ::protobuf_datanode_2eproto::TableStruct;
  friend void ::protobuf_datanode_2eproto::InitDefaultskeepalive_reqImpl();
};
// -------------------------------------------------------------------

class keepalive_resp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bdfs.keepalive_resp) */ {
 public:
  keepalive_resp();
  virtual ~keepalive_resp();

  keepalive_resp(const keepalive_resp& from);

  inline keepalive_resp& operator=(const keepalive_resp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  keepalive_resp(keepalive_resp&& from) noexcept
    : keepalive_resp() {
    *this = ::std::move(from);
  }

  inline keepalive_resp& operator=(keepalive_resp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const keepalive_resp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const keepalive_resp* internal_default_instance() {
    return reinterpret_cast<const keepalive_resp*>(
               &_keepalive_resp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(keepalive_resp* other);
  friend void swap(keepalive_resp& a, keepalive_resp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline keepalive_resp* New() const PROTOBUF_FINAL { return New(NULL); }

  keepalive_resp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const keepalive_resp& from);
  void MergeFrom(const keepalive_resp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(keepalive_resp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodename = 1;
  void clear_nodename();
  static const int kNodenameFieldNumber = 1;
  const ::std::string& nodename() const;
  void set_nodename(const ::std::string& value);
  #if LANG_CXX11
  void set_nodename(::std::string&& value);
  #endif
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  ::std::string* mutable_nodename();
  ::std::string* release_nodename();
  void set_allocated_nodename(::std::string* nodename);

  // @@protoc_insertion_point(class_scope:bdfs.keepalive_resp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  mutable int _cached_size_;
  friend struct ::protobuf_datanode_2eproto::TableStruct;
  friend void ::protobuf_datanode_2eproto::InitDefaultskeepalive_respImpl();
};
// -------------------------------------------------------------------

class connect_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bdfs.connect_req) */ {
 public:
  connect_req();
  virtual ~connect_req();

  connect_req(const connect_req& from);

  inline connect_req& operator=(const connect_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  connect_req(connect_req&& from) noexcept
    : connect_req() {
    *this = ::std::move(from);
  }

  inline connect_req& operator=(connect_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const connect_req& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const connect_req* internal_default_instance() {
    return reinterpret_cast<const connect_req*>(
               &_connect_req_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(connect_req* other);
  friend void swap(connect_req& a, connect_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline connect_req* New() const PROTOBUF_FINAL { return New(NULL); }

  connect_req* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const connect_req& from);
  void MergeFrom(const connect_req& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(connect_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ipaddress = 1;
  void clear_ipaddress();
  static const int kIpaddressFieldNumber = 1;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_ipaddress(::std::string&& value);
  #endif
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // string nodename = 2;
  void clear_nodename();
  static const int kNodenameFieldNumber = 2;
  const ::std::string& nodename() const;
  void set_nodename(const ::std::string& value);
  #if LANG_CXX11
  void set_nodename(::std::string&& value);
  #endif
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  ::std::string* mutable_nodename();
  ::std::string* release_nodename();
  void set_allocated_nodename(::std::string* nodename);

  // int64 sizeGB = 3;
  void clear_sizegb();
  static const int kSizeGBFieldNumber = 3;
  ::google::protobuf::int64 sizegb() const;
  void set_sizegb(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bdfs.connect_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  ::google::protobuf::int64 sizegb_;
  mutable int _cached_size_;
  friend struct ::protobuf_datanode_2eproto::TableStruct;
  friend void ::protobuf_datanode_2eproto::InitDefaultsconnect_reqImpl();
};
// -------------------------------------------------------------------

class connect_resp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bdfs.connect_resp) */ {
 public:
  connect_resp();
  virtual ~connect_resp();

  connect_resp(const connect_resp& from);

  inline connect_resp& operator=(const connect_resp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  connect_resp(connect_resp&& from) noexcept
    : connect_resp() {
    *this = ::std::move(from);
  }

  inline connect_resp& operator=(connect_resp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const connect_resp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const connect_resp* internal_default_instance() {
    return reinterpret_cast<const connect_resp*>(
               &_connect_resp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(connect_resp* other);
  friend void swap(connect_resp& a, connect_resp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline connect_resp* New() const PROTOBUF_FINAL { return New(NULL); }

  connect_resp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const connect_resp& from);
  void MergeFrom(const connect_resp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(connect_resp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ipaddress = 1;
  void clear_ipaddress();
  static const int kIpaddressFieldNumber = 1;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_ipaddress(::std::string&& value);
  #endif
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // string nodename = 2;
  void clear_nodename();
  static const int kNodenameFieldNumber = 2;
  const ::std::string& nodename() const;
  void set_nodename(const ::std::string& value);
  #if LANG_CXX11
  void set_nodename(::std::string&& value);
  #endif
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  ::std::string* mutable_nodename();
  ::std::string* release_nodename();
  void set_allocated_nodename(::std::string* nodename);

  // int64 sizeGB = 3;
  void clear_sizegb();
  static const int kSizeGBFieldNumber = 3;
  ::google::protobuf::int64 sizegb() const;
  void set_sizegb(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bdfs.connect_resp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  ::google::protobuf::int64 sizegb_;
  mutable int _cached_size_;
  friend struct ::protobuf_datanode_2eproto::TableStruct;
  friend void ::protobuf_datanode_2eproto::InitDefaultsconnect_respImpl();
};
// -------------------------------------------------------------------

class disconnect_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bdfs.disconnect_req) */ {
 public:
  disconnect_req();
  virtual ~disconnect_req();

  disconnect_req(const disconnect_req& from);

  inline disconnect_req& operator=(const disconnect_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  disconnect_req(disconnect_req&& from) noexcept
    : disconnect_req() {
    *this = ::std::move(from);
  }

  inline disconnect_req& operator=(disconnect_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const disconnect_req& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const disconnect_req* internal_default_instance() {
    return reinterpret_cast<const disconnect_req*>(
               &_disconnect_req_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(disconnect_req* other);
  friend void swap(disconnect_req& a, disconnect_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline disconnect_req* New() const PROTOBUF_FINAL { return New(NULL); }

  disconnect_req* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const disconnect_req& from);
  void MergeFrom(const disconnect_req& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(disconnect_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ipaddress = 1;
  void clear_ipaddress();
  static const int kIpaddressFieldNumber = 1;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_ipaddress(::std::string&& value);
  #endif
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // string nodename = 2;
  void clear_nodename();
  static const int kNodenameFieldNumber = 2;
  const ::std::string& nodename() const;
  void set_nodename(const ::std::string& value);
  #if LANG_CXX11
  void set_nodename(::std::string&& value);
  #endif
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  ::std::string* mutable_nodename();
  ::std::string* release_nodename();
  void set_allocated_nodename(::std::string* nodename);

  // @@protoc_insertion_point(class_scope:bdfs.disconnect_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  mutable int _cached_size_;
  friend struct ::protobuf_datanode_2eproto::TableStruct;
  friend void ::protobuf_datanode_2eproto::InitDefaultsdisconnect_reqImpl();
};
// -------------------------------------------------------------------

class disconnect_resp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bdfs.disconnect_resp) */ {
 public:
  disconnect_resp();
  virtual ~disconnect_resp();

  disconnect_resp(const disconnect_resp& from);

  inline disconnect_resp& operator=(const disconnect_resp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  disconnect_resp(disconnect_resp&& from) noexcept
    : disconnect_resp() {
    *this = ::std::move(from);
  }

  inline disconnect_resp& operator=(disconnect_resp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const disconnect_resp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const disconnect_resp* internal_default_instance() {
    return reinterpret_cast<const disconnect_resp*>(
               &_disconnect_resp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(disconnect_resp* other);
  friend void swap(disconnect_resp& a, disconnect_resp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline disconnect_resp* New() const PROTOBUF_FINAL { return New(NULL); }

  disconnect_resp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const disconnect_resp& from);
  void MergeFrom(const disconnect_resp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(disconnect_resp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ipaddress = 1;
  void clear_ipaddress();
  static const int kIpaddressFieldNumber = 1;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_ipaddress(::std::string&& value);
  #endif
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // string nodename = 2;
  void clear_nodename();
  static const int kNodenameFieldNumber = 2;
  const ::std::string& nodename() const;
  void set_nodename(const ::std::string& value);
  #if LANG_CXX11
  void set_nodename(::std::string&& value);
  #endif
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  ::std::string* mutable_nodename();
  ::std::string* release_nodename();
  void set_allocated_nodename(::std::string* nodename);

  // @@protoc_insertion_point(class_scope:bdfs.disconnect_resp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::internal::ArenaStringPtr nodename_;
  mutable int _cached_size_;
  friend struct ::protobuf_datanode_2eproto::TableStruct;
  friend void ::protobuf_datanode_2eproto::InitDefaultsdisconnect_respImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// keepalive_req

// string nodename = 1;
inline void keepalive_req::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& keepalive_req::nodename() const {
  // @@protoc_insertion_point(field_get:bdfs.keepalive_req.nodename)
  return nodename_.GetNoArena();
}
inline void keepalive_req::set_nodename(const ::std::string& value) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.keepalive_req.nodename)
}
#if LANG_CXX11
inline void keepalive_req::set_nodename(::std::string&& value) {
  
  nodename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.keepalive_req.nodename)
}
#endif
inline void keepalive_req::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.keepalive_req.nodename)
}
inline void keepalive_req::set_nodename(const char* value, size_t size) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.keepalive_req.nodename)
}
inline ::std::string* keepalive_req::mutable_nodename() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.keepalive_req.nodename)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* keepalive_req::release_nodename() {
  // @@protoc_insertion_point(field_release:bdfs.keepalive_req.nodename)
  
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void keepalive_req::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    
  } else {
    
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:bdfs.keepalive_req.nodename)
}

// -------------------------------------------------------------------

// keepalive_resp

// string nodename = 1;
inline void keepalive_resp::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& keepalive_resp::nodename() const {
  // @@protoc_insertion_point(field_get:bdfs.keepalive_resp.nodename)
  return nodename_.GetNoArena();
}
inline void keepalive_resp::set_nodename(const ::std::string& value) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.keepalive_resp.nodename)
}
#if LANG_CXX11
inline void keepalive_resp::set_nodename(::std::string&& value) {
  
  nodename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.keepalive_resp.nodename)
}
#endif
inline void keepalive_resp::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.keepalive_resp.nodename)
}
inline void keepalive_resp::set_nodename(const char* value, size_t size) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.keepalive_resp.nodename)
}
inline ::std::string* keepalive_resp::mutable_nodename() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.keepalive_resp.nodename)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* keepalive_resp::release_nodename() {
  // @@protoc_insertion_point(field_release:bdfs.keepalive_resp.nodename)
  
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void keepalive_resp::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    
  } else {
    
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:bdfs.keepalive_resp.nodename)
}

// -------------------------------------------------------------------

// connect_req

// string ipaddress = 1;
inline void connect_req::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& connect_req::ipaddress() const {
  // @@protoc_insertion_point(field_get:bdfs.connect_req.ipaddress)
  return ipaddress_.GetNoArena();
}
inline void connect_req::set_ipaddress(const ::std::string& value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.connect_req.ipaddress)
}
#if LANG_CXX11
inline void connect_req::set_ipaddress(::std::string&& value) {
  
  ipaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.connect_req.ipaddress)
}
#endif
inline void connect_req::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.connect_req.ipaddress)
}
inline void connect_req::set_ipaddress(const char* value, size_t size) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.connect_req.ipaddress)
}
inline ::std::string* connect_req::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.connect_req.ipaddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* connect_req::release_ipaddress() {
  // @@protoc_insertion_point(field_release:bdfs.connect_req.ipaddress)
  
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void connect_req::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:bdfs.connect_req.ipaddress)
}

// string nodename = 2;
inline void connect_req::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& connect_req::nodename() const {
  // @@protoc_insertion_point(field_get:bdfs.connect_req.nodename)
  return nodename_.GetNoArena();
}
inline void connect_req::set_nodename(const ::std::string& value) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.connect_req.nodename)
}
#if LANG_CXX11
inline void connect_req::set_nodename(::std::string&& value) {
  
  nodename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.connect_req.nodename)
}
#endif
inline void connect_req::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.connect_req.nodename)
}
inline void connect_req::set_nodename(const char* value, size_t size) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.connect_req.nodename)
}
inline ::std::string* connect_req::mutable_nodename() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.connect_req.nodename)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* connect_req::release_nodename() {
  // @@protoc_insertion_point(field_release:bdfs.connect_req.nodename)
  
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void connect_req::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    
  } else {
    
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:bdfs.connect_req.nodename)
}

// int64 sizeGB = 3;
inline void connect_req::clear_sizegb() {
  sizegb_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 connect_req::sizegb() const {
  // @@protoc_insertion_point(field_get:bdfs.connect_req.sizeGB)
  return sizegb_;
}
inline void connect_req::set_sizegb(::google::protobuf::int64 value) {
  
  sizegb_ = value;
  // @@protoc_insertion_point(field_set:bdfs.connect_req.sizeGB)
}

// -------------------------------------------------------------------

// connect_resp

// string ipaddress = 1;
inline void connect_resp::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& connect_resp::ipaddress() const {
  // @@protoc_insertion_point(field_get:bdfs.connect_resp.ipaddress)
  return ipaddress_.GetNoArena();
}
inline void connect_resp::set_ipaddress(const ::std::string& value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.connect_resp.ipaddress)
}
#if LANG_CXX11
inline void connect_resp::set_ipaddress(::std::string&& value) {
  
  ipaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.connect_resp.ipaddress)
}
#endif
inline void connect_resp::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.connect_resp.ipaddress)
}
inline void connect_resp::set_ipaddress(const char* value, size_t size) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.connect_resp.ipaddress)
}
inline ::std::string* connect_resp::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.connect_resp.ipaddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* connect_resp::release_ipaddress() {
  // @@protoc_insertion_point(field_release:bdfs.connect_resp.ipaddress)
  
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void connect_resp::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:bdfs.connect_resp.ipaddress)
}

// string nodename = 2;
inline void connect_resp::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& connect_resp::nodename() const {
  // @@protoc_insertion_point(field_get:bdfs.connect_resp.nodename)
  return nodename_.GetNoArena();
}
inline void connect_resp::set_nodename(const ::std::string& value) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.connect_resp.nodename)
}
#if LANG_CXX11
inline void connect_resp::set_nodename(::std::string&& value) {
  
  nodename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.connect_resp.nodename)
}
#endif
inline void connect_resp::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.connect_resp.nodename)
}
inline void connect_resp::set_nodename(const char* value, size_t size) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.connect_resp.nodename)
}
inline ::std::string* connect_resp::mutable_nodename() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.connect_resp.nodename)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* connect_resp::release_nodename() {
  // @@protoc_insertion_point(field_release:bdfs.connect_resp.nodename)
  
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void connect_resp::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    
  } else {
    
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:bdfs.connect_resp.nodename)
}

// int64 sizeGB = 3;
inline void connect_resp::clear_sizegb() {
  sizegb_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 connect_resp::sizegb() const {
  // @@protoc_insertion_point(field_get:bdfs.connect_resp.sizeGB)
  return sizegb_;
}
inline void connect_resp::set_sizegb(::google::protobuf::int64 value) {
  
  sizegb_ = value;
  // @@protoc_insertion_point(field_set:bdfs.connect_resp.sizeGB)
}

// -------------------------------------------------------------------

// disconnect_req

// string ipaddress = 1;
inline void disconnect_req::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& disconnect_req::ipaddress() const {
  // @@protoc_insertion_point(field_get:bdfs.disconnect_req.ipaddress)
  return ipaddress_.GetNoArena();
}
inline void disconnect_req::set_ipaddress(const ::std::string& value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.disconnect_req.ipaddress)
}
#if LANG_CXX11
inline void disconnect_req::set_ipaddress(::std::string&& value) {
  
  ipaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.disconnect_req.ipaddress)
}
#endif
inline void disconnect_req::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.disconnect_req.ipaddress)
}
inline void disconnect_req::set_ipaddress(const char* value, size_t size) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.disconnect_req.ipaddress)
}
inline ::std::string* disconnect_req::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.disconnect_req.ipaddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* disconnect_req::release_ipaddress() {
  // @@protoc_insertion_point(field_release:bdfs.disconnect_req.ipaddress)
  
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void disconnect_req::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:bdfs.disconnect_req.ipaddress)
}

// string nodename = 2;
inline void disconnect_req::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& disconnect_req::nodename() const {
  // @@protoc_insertion_point(field_get:bdfs.disconnect_req.nodename)
  return nodename_.GetNoArena();
}
inline void disconnect_req::set_nodename(const ::std::string& value) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.disconnect_req.nodename)
}
#if LANG_CXX11
inline void disconnect_req::set_nodename(::std::string&& value) {
  
  nodename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.disconnect_req.nodename)
}
#endif
inline void disconnect_req::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.disconnect_req.nodename)
}
inline void disconnect_req::set_nodename(const char* value, size_t size) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.disconnect_req.nodename)
}
inline ::std::string* disconnect_req::mutable_nodename() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.disconnect_req.nodename)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* disconnect_req::release_nodename() {
  // @@protoc_insertion_point(field_release:bdfs.disconnect_req.nodename)
  
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void disconnect_req::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    
  } else {
    
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:bdfs.disconnect_req.nodename)
}

// -------------------------------------------------------------------

// disconnect_resp

// string ipaddress = 1;
inline void disconnect_resp::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& disconnect_resp::ipaddress() const {
  // @@protoc_insertion_point(field_get:bdfs.disconnect_resp.ipaddress)
  return ipaddress_.GetNoArena();
}
inline void disconnect_resp::set_ipaddress(const ::std::string& value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.disconnect_resp.ipaddress)
}
#if LANG_CXX11
inline void disconnect_resp::set_ipaddress(::std::string&& value) {
  
  ipaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.disconnect_resp.ipaddress)
}
#endif
inline void disconnect_resp::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.disconnect_resp.ipaddress)
}
inline void disconnect_resp::set_ipaddress(const char* value, size_t size) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.disconnect_resp.ipaddress)
}
inline ::std::string* disconnect_resp::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.disconnect_resp.ipaddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* disconnect_resp::release_ipaddress() {
  // @@protoc_insertion_point(field_release:bdfs.disconnect_resp.ipaddress)
  
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void disconnect_resp::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:bdfs.disconnect_resp.ipaddress)
}

// string nodename = 2;
inline void disconnect_resp::clear_nodename() {
  nodename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& disconnect_resp::nodename() const {
  // @@protoc_insertion_point(field_get:bdfs.disconnect_resp.nodename)
  return nodename_.GetNoArena();
}
inline void disconnect_resp::set_nodename(const ::std::string& value) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bdfs.disconnect_resp.nodename)
}
#if LANG_CXX11
inline void disconnect_resp::set_nodename(::std::string&& value) {
  
  nodename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bdfs.disconnect_resp.nodename)
}
#endif
inline void disconnect_resp::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bdfs.disconnect_resp.nodename)
}
inline void disconnect_resp::set_nodename(const char* value, size_t size) {
  
  nodename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bdfs.disconnect_resp.nodename)
}
inline ::std::string* disconnect_resp::mutable_nodename() {
  
  // @@protoc_insertion_point(field_mutable:bdfs.disconnect_resp.nodename)
  return nodename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* disconnect_resp::release_nodename() {
  // @@protoc_insertion_point(field_release:bdfs.disconnect_resp.nodename)
  
  return nodename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void disconnect_resp::set_allocated_nodename(::std::string* nodename) {
  if (nodename != NULL) {
    
  } else {
    
  }
  nodename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodename);
  // @@protoc_insertion_point(field_set_allocated:bdfs.disconnect_resp.nodename)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bdfs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_datanode_2eproto__INCLUDED
